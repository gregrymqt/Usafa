# ==================================
# CONFIGURAÇÃO DO SPRING BOOT
# ==================================

# Conexão com o Banco de Dados
# No Docker, ele vai usar o host 'db' (que vem do docker-compose)
# Se rodar local, ele usará 'localhost'
spring.datasource.url=jdbc:postgresql://${DB_HOST:db}:${DB_PORT:5432}/${DB_NAME:usafa}
spring.datasource.username=${DB_USER:postgres}
spring.datasource.password=${DB_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# Redis
# No Docker, usa o host 'cache'. Localmente, 'localhost'.
spring.data.redis.host=${REDIS_HOST:cache}
spring.data.redis.port=6379

# RabbitMQ
# No Docker, usa o host 'mq'. Localmente, 'localhost'.
spring.rabbitmq.host=${RABBITMQ_HOST:mq}
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest

# =======================================
# MONGODB CONFIG
# =======================================
# Conecta ao serviço 'mongo' do seu docker-compose.
# Usa as variáveis de ambiente que você definiu no docker-compose.
spring.data.mongodb.uri=mongodb://${MONGO_USER}:${MONGO_PASSWORD}@mongo:27017/${MONGO_DB_NAME}?authSource=admin

# Configuração do Google OAuth2
# Ele vai ler as variáveis GOOGLE_CLIENT_ID e GOOGLE_CLIENT_SECRET do .env
spring.security.oauth2.client.registration.google.client-id=${GOOGLE_CLIENT_ID}
spring.security.oauth2.client.registration.google.client-secret=${GOOGLE_CLIENT_SECRET}
spring.security.oauth2.client.registration.google.scope=openid,email,profile
spring.security.oauth2.client.registration.google.authorization-grant-type=authorization_code
# Mapeia a URL de redirecionamento para o Spring Security
spring.security.oauth2.client.registration.google.redirect-uri=${APP_OAUTH2_REDIRECT_URL}/login/oauth2/code/google

# Configuração do JWT (Lido pelo @Value no JwtUtils)
# O Java pede "app.jwt.secret", que pega o valor de "JWT_SECRET_KEY" do .env
app.jwt.secret=${JWT_SECRET_KEY}
app.jwt.expiration-ms=${JWT_EXPIRATION_TIME}

# URLs da Aplicação (Lido pelo @Value em outras classes)
# (A URL para onde o Spring redireciona o usuário após o login do Google)
app.oauth2.redirect-url=${FRONTEND_MAIN_URL}/auth/token?token=
# (A URL que o CORS deve permitir)
app.cors.allowed-origin=${FRONTEND_CORS_URLS}

# ==================================
# CONFIGURAÇÃO DE LOGGING
# ==================================
# --- 1. Onde salvar o log ---
# Define um nome e local para o arquivo de log principal.
logging.file.name=logs/usafa-backend.log

# --- 2. Controle de Rotação (A SOLUÇÃO) ---
# Define o tamanho máximo de CADA arquivo de log antes de "rotacionar" (criar um novo).
# O seu log de 461MB será dividido em arquivos de 10MB.
logging.file.max-size=10MB

# Define quantos arquivos de log antigos devem ser guardados (ex: usafa-backend.log.1, .2, etc.)
# Isso impede que sua pasta de logs cresça para sempre.
logging.file.max-history=7

# Opcional: Define um limite MÁXIMO para o tamanho total de todos os arquivos de log.
# (ex: 7 arquivos de 10MB = 70MB. Vamos definir um teto de 100MB por segurança).
logging.file.total-size-cap=100MB

# --- 3. Controle de Nível (Menos "Ruído") ---
# Define o nível de log padrão para a aplicação inteira.
# Mudar de INFO para WARN vai reduzir drasticamente a quantidade de logs.
logging.level.root=WARN

# Define o nível específico para o SEU código.
# Assim, você vê os logs da sua aplicação (INFO), mas não os do Spring (só WARN/ERROR).
# (Ajuste o pacote para o seu projeto)
logging.level.br.edu.fatecpg.usafa=INFO

# Silencia frameworks barulhentos, mostrando apenas erros.
logging.level.org.springframework=ERROR
logging.level.org.hibernate=ERROR

# --- 4. Seu Padrão de Formato (Mantido) ---
# Este é o padrão que você já tinha, e ele é ótimo.
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

# Opcional: Aplica um padrão mais limpo para o console (quando você roda localmente)
logging.pattern.console=%d{HH:mm:ss.SSS} %-5level %logger{36} - %msg%n